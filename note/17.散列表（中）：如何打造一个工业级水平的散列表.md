# 1. 面试题目：如何设计一个工业级的散列函数？
# 1.1. 思路：
- 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？结合学过的知识，我觉的应该有这样的要求：
    - 支持快速的查询、插入、删除操作
    - 内存占用合理，不能浪费过多空间
    - 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。

# 1.2. 方案：
- 如何设计这样一个散列表呢？根据前面讲到的知识，我会从3个方面来考虑设计思路：
    - 设计一个合适的散列函数；
    - 定义装载因子阈值，并且设计动态扩容策略；
    - 选择合适的散列冲突解决方法。


# 2. 知识总结：
# 2.1. 如何设计散列函数？
- 要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。
- 除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。
- 常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。

# 2.2. 如何根据装载因子动态扩容？
- 如何设置装载因子阈值？
    - 可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。
    - 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。

- 如何避免低效扩容？分批扩容
    - 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。
    
    - 分批扩容的查询操作：先查新散列表，再查老散列表。
    - 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。

# 2.3. 如何选择散列冲突解决方法？
- 常见的2中方法：开放寻址法和链表法。
- 大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。
- 但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。


# 3. 工业级散列表举例分析（Java 中的 HashMap 这样一个工业级的散列表）

## 3.1. 初始大小
- HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。

## 3.2. 装载因子和动态扩容
- 最大装载因子默认是 0.75，当 HashMap中元素个数超过0.75*capacity（capacity表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。


## 3.3. 散列冲突解决方法
- HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。

- 在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。

## 3.4. 散列函数
```
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capitity -1); //capicity表示散列表的大小
}
```


