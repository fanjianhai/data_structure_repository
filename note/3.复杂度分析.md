# 1. 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗
## 1.1. 大 O 复杂度表示法
- 代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度，简称时间复杂度
```
T(n) = O(f(n))
T(n):   代码执行的时间
n：     数据规模的大小
f(n)：  每行代码执行的次数总和
O：     表示代码的执行时间 T(n) 与 f(n) 表达式成正比
```

## 1.2. 时间复杂度分析方法
- 只关注循环执行次数最多的一段代码（通常忽略公式中的常量、低阶、系数， 只需要记录一个最大阶的量级就可以了）
- 加法法则： 总复杂度等于量级最大的那段代码的复杂度
```
如果T1(n) = O(f(n))，T2(n) = O(g(n))，那么 T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
```
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
```
如果T1(n) = O(f(n))，T2(n) = O(g(n))，那么 T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))
```

## 1.3. 几种常见时间复杂度实例分析
- 多项式量级
    - O(1)： 常量阶 只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)
    - O(logn)：对数阶
        - 链接：https://www.cnblogs.com/chenxi188/p/11050016.html
    ``` 
    i=1;
    while (i <= n)  {
        i = i * 2;
    }
    ```
    - O(n): 线性阶
    - O(nlogn)：线性对数阶 (比如：归并排序、快速排序)
    - O(n2): 平方阶
    - O(n3): 立方阶
    - O(m+n)、O(m*n)
    ``` 
    int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i < m; ++i) {
        sum_1 = sum_1 + i;
    }
    
    int sum_2 = 0;
    int j = 1;
    for (; j < n; ++j) {
        sum_2 = sum_2 + j;
    }
    
    return sum_1 + sum_2;
    }
    // 注意：针对这种情况， 加法法则就不适用了，乘法法则依然适用

    ```
    

- 非多项式量级
    - O(2n)：指数阶
    - O(n!)：阶乘阶


## 1.4. 空间复杂度
- 算法的存储空间与数据规模之间的增长关系

## 1.5. 常见的空间复杂度
- O(1)
- O(n)
- O(n2)

# 2. 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度
## 2.1. 最好、最坏、平均情况时间复杂度
```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}

```
- 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度
- 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度
- 平均情况复杂度，应该把概率考虑进去，进行加权时间复杂度

## 2.2. 均摊时间复杂度
```
 // array 表示一个长度为 n 的数组
 // 代码中的 array.length 就等于 n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }

```

- 分析方法
    - 摊还分析（平摊分析）
- 思路：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)


